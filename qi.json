{"language":"Solidity","sources":{"qistake/QiStakeFactory.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\n/**\r\n * @title QiStake Factory\r\n * @author bilal07karadeniz\r\n * @notice Factory contract for deploying QiStakePool contracts on QIE Network\r\n * @dev Manages pool creation with native coin fees and maintains a registry of all pools\r\n */\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./QiStakePool.sol\";\r\n\r\ncontract QiStakeFactory is Ownable, ReentrancyGuard {\r\n    /// @notice Fee required to create a new staking pool (in wei)\r\n    uint256 public creationFee;\r\n\r\n    /// @notice Grace period for pools (time after pool ends for users to claim rewards)\r\n    uint256 public gracePeriod = 90 days;\r\n\r\n    /// @notice Array of all deployed pool addresses\r\n    address[] public deployedPools;\r\n\r\n    /// @notice Mapping to check if an address is a valid pool\r\n    mapping(address => bool) public isPool;\r\n\r\n    /// @notice Emitted when a new pool is created\r\n    event PoolCreated(\r\n        address indexed poolAddress,\r\n        address indexed creator,\r\n        address indexed stakingToken,\r\n        uint256 rewardAmount,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    /// @notice Emitted when creation fee is updated\r\n    event CreationFeeUpdated(uint256 oldFee, uint256 newFee);\r\n    \r\n    /// @notice Emitted when fees are withdrawn\r\n    event FeesWithdrawn(address indexed to, uint256 amount);\r\n\r\n    /// @notice Emitted when grace period is updated\r\n    event GracePeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\r\n\r\n    /**\r\n     * @notice Initializes the factory with an initial creation fee\r\n     * @param _initialFee Initial fee in wei required to create a pool\r\n     */\r\n    constructor(uint256 _initialFee) Ownable(msg.sender) {\r\n        creationFee = _initialFee;\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new staking pool\r\n     * @dev Caller must send exactly the creation fee in native coin (QIE) and approve reward tokens\r\n     * @param _stakingToken Address of the token to be staked\r\n     * @param _rewardAmount Total amount of rewards to be distributed (before any transfer fees)\r\n     * @param _website Project website URL\r\n     * @param _telegram Telegram link\r\n     * @param _twitter Twitter handle or link\r\n     * @param _description Project description (max 150 characters)\r\n     * @param _logoUrl URL to project logo\r\n     * @return poolAddress Address of the newly created pool\r\n     */\r\n    function createPool(\r\n        address _stakingToken,\r\n        uint256 _rewardAmount,\r\n        string memory _website,\r\n        string memory _telegram,\r\n        string memory _twitter,\r\n        string memory _description,\r\n        string memory _logoUrl\r\n    ) external payable nonReentrant returns (address poolAddress) {\r\n        require(msg.value == creationFee, \"Incorrect creation fee\");\r\n        require(_stakingToken != address(0), \"Invalid token address\");\r\n        require(_rewardAmount > 0, \"Reward amount must be positive\");\r\n        require(bytes(_description).length <= 150, \"Description too long\");\r\n\r\n        IERC20 token = IERC20(_stakingToken);\r\n\r\n        // Step 1: Transfer tokens from creator to factory (supports fee-on-transfer)\r\n        uint256 balanceBefore = token.balanceOf(address(this));\r\n        require(token.transferFrom(msg.sender, address(this), _rewardAmount), \"Token transfer failed\");\r\n        uint256 receivedByFactory = token.balanceOf(address(this)) - balanceBefore;\r\n        require(receivedByFactory > 0, \"No tokens received\");\r\n\r\n        // Step 2: Deploy new pool\r\n        QiStakePool newPool = new QiStakePool(\r\n            address(this),\r\n            msg.sender,\r\n            _stakingToken,\r\n            gracePeriod,\r\n            _website,\r\n            _telegram,\r\n            _twitter,\r\n            _description,\r\n            _logoUrl\r\n        );\r\n\r\n        poolAddress = address(newPool);\r\n\r\n        // Step 3: Transfer tokens from factory to pool (supports fee-on-transfer)\r\n        require(token.transfer(poolAddress, receivedByFactory), \"Transfer to pool failed\");\r\n\r\n        // Step 4: Initialize rewards on pool (pool will measure actual received amount)\r\n        newPool.initializeRewards();\r\n\r\n        // Register pool\r\n        deployedPools.push(poolAddress);\r\n        isPool[poolAddress] = true;\r\n\r\n        emit PoolCreated(poolAddress, msg.sender, _stakingToken, _rewardAmount, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the creation fee\r\n     * @dev Only callable by owner\r\n     * @param _newFee New fee in wei\r\n     */\r\n    function setCreationFee(uint256 _newFee) external onlyOwner {\r\n        uint256 oldFee = creationFee;\r\n        creationFee = _newFee;\r\n        emit CreationFeeUpdated(oldFee, _newFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the grace period for new pools\r\n     * @dev Only callable by owner. Minimum 30 days to protect users.\r\n     * @param _newPeriod New grace period in seconds\r\n     */\r\n    function setGracePeriod(uint256 _newPeriod) external onlyOwner {\r\n        require(_newPeriod >= 30 days, \"Grace period too short\");\r\n        uint256 oldPeriod = gracePeriod;\r\n        gracePeriod = _newPeriod;\r\n        emit GracePeriodUpdated(oldPeriod, _newPeriod);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws accumulated fees to owner\r\n     * @dev Only callable by owner\r\n     */\r\n    function withdrawFees() external onlyOwner nonReentrant {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No fees to withdraw\");\r\n        \r\n        (bool success, ) = payable(owner()).call{value: balance}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        \r\n        emit FeesWithdrawn(owner(), balance);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total number of pools created\r\n     * @return Total count of deployed pools\r\n     */\r\n    function totalPools() external view returns (uint256) {\r\n        return deployedPools.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a batch of pool addresses\r\n     * @dev Use this to paginate through pools to avoid gas issues\r\n     * @param _offset Starting index\r\n     * @param _limit Maximum number of addresses to return\r\n     * @return Pool addresses in the specified range\r\n     */\r\n    function getPools(uint256 _offset, uint256 _limit) external view returns (address[] memory) {\r\n        require(_offset < deployedPools.length, \"Offset out of bounds\");\r\n        \r\n        uint256 end = _offset + _limit;\r\n        if (end > deployedPools.length) {\r\n            end = deployedPools.length;\r\n        }\r\n        \r\n        uint256 size = end - _offset;\r\n        address[] memory pools = new address[](size);\r\n        \r\n        for (uint256 i = 0; i < size; i++) {\r\n            pools[i] = deployedPools[_offset + i];\r\n        }\r\n        \r\n        return pools;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns all pool addresses\r\n     * @dev Use getPools() for large datasets to avoid gas issues\r\n     * @return Array of all deployed pool addresses\r\n     */\r\n    function getAllPools() external view returns (address[] memory) {\r\n        return deployedPools;\r\n    }\r\n\r\n    /**\r\n     * @notice Enables contract to receive native coins\r\n     */\r\n    receive() external payable {}\r\n}\r\n"},"qistake/QiStakePool.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\n/**\r\n * @title QiStake Pool\r\n * @author bilal07karadeniz\r\n * @notice Individual staking pool with Synthetix-style reward distribution\r\n * @dev Supports fee-on-transfer tokens and provides O(1) gas efficiency for reward calculations\r\n */\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\ncontract QiStakePool is ReentrancyGuard {\r\n    /// @notice The token being staked\r\n    IERC20 public immutable stakingToken;\r\n\r\n    /// @notice Factory that deployed this pool\r\n    address public immutable factory;\r\n\r\n    /// @notice Creator and owner of the pool\r\n    address public immutable creator;\r\n\r\n    /// @notice Timestamp when pool was created\r\n    uint256 public immutable createdAt;\r\n\r\n    /// @notice Duration of the pool in seconds (365 days)\r\n    uint256 public constant DURATION = 365 days;\r\n\r\n    /// @notice Pool start timestamp (set when first stake happens)\r\n    uint256 public startTime;\r\n\r\n    /// @notice Pool end timestamp (startTime + DURATION)\r\n    uint256 public endTime;\r\n\r\n    /// @notice Total tokens staked in the pool\r\n    uint256 public totalStaked;\r\n\r\n    /// @notice Reward per token stored\r\n    uint256 public rewardPerTokenStored;\r\n\r\n    /// @notice Last time rewards were updated\r\n    uint256 public lastUpdateTime;\r\n\r\n    /// @notice Actual reward amount received (after fee-on-transfer)\r\n    uint256 public actualRewardAmount;\r\n\r\n    /// @notice Whether rewards have been initialized by factory\r\n    bool public rewardsDeposited;\r\n\r\n    /// @notice Whether the pool has started (first stake occurred)\r\n    bool public poolStarted;\r\n\r\n    /// @notice Timestamp when pool became empty (for pause tracking)\r\n    uint256 public pauseStartTime;\r\n\r\n    /// @notice Total time the pool was paused (no stakers)\r\n    uint256 public totalPausedTime;\r\n\r\n    /// @notice Grace period after pool ends for users to claim (set by factory)\r\n    uint256 public immutable gracePeriod;\r\n\r\n    /// @notice Whether remaining rewards have been withdrawn by creator\r\n    bool public remainingRewardsWithdrawn;\r\n\r\n    /// @notice Project metadata\r\n    struct PoolMetadata {\r\n        string website;\r\n        string telegram;\r\n        string twitter;\r\n        string description;\r\n        string logoUrl;\r\n    }\r\n    \r\n    PoolMetadata public metadata;\r\n\r\n    /// @notice User staking information\r\n    struct UserInfo {\r\n        uint256 stakedBalance;\r\n        uint256 rewardPerTokenPaid;\r\n        uint256 rewards;\r\n    }\r\n    \r\n    /// @notice Mapping of user address to their staking info\r\n    mapping(address => UserInfo) public userInfo;\r\n\r\n    /// @notice Emitted when rewards are deposited\r\n    event RewardsDeposited(uint256 amount, uint256 actualAmount);\r\n    \r\n    /// @notice Emitted when a user stakes tokens\r\n    event Staked(address indexed user, uint256 amount, uint256 actualAmount);\r\n    \r\n    /// @notice Emitted when a user unstakes tokens\r\n    event Unstaked(address indexed user, uint256 amount);\r\n    \r\n    /// @notice Emitted when rewards are claimed\r\n    event RewardsClaimed(address indexed user, uint256 amount);\r\n\r\n    /// @notice Emitted when pool starts (first stake)\r\n    event PoolStarted(uint256 startTime, uint256 endTime);\r\n\r\n    /// @notice Emitted when pool resumes from pause\r\n    event PoolResumed(uint256 pausedDuration, uint256 newEndTime);\r\n\r\n    /// @notice Emitted when pool becomes empty (paused)\r\n    event PoolPaused(uint256 pauseTime);\r\n\r\n    /// @notice Emitted when creator withdraws remaining rewards\r\n    event RemainingRewardsWithdrawn(address indexed creator, uint256 amount);\r\n\r\n    /**\r\n     * @notice Initializes the staking pool\r\n     * @param _factory Address of the factory that deployed this pool\r\n     * @param _creator Address of the pool creator\r\n     * @param _stakingToken Address of the token to be staked\r\n     * @param _gracePeriod Grace period in seconds (set by factory)\r\n     * @param _website Project website\r\n     * @param _telegram Telegram link\r\n     * @param _twitter Twitter handle\r\n     * @param _description Project description\r\n     * @param _logoUrl Logo URL\r\n     */\r\n    constructor(\r\n        address _factory,\r\n        address _creator,\r\n        address _stakingToken,\r\n        uint256 _gracePeriod,\r\n        string memory _website,\r\n        string memory _telegram,\r\n        string memory _twitter,\r\n        string memory _description,\r\n        string memory _logoUrl\r\n    ) {\r\n        require(_factory != address(0), \"Invalid factory\");\r\n        require(_creator != address(0), \"Invalid creator\");\r\n        require(_stakingToken != address(0), \"Invalid token\");\r\n\r\n        factory = _factory;\r\n        creator = _creator;\r\n        stakingToken = IERC20(_stakingToken);\r\n        gracePeriod = _gracePeriod;\r\n        createdAt = block.timestamp;\r\n\r\n        // Note: startTime, endTime, lastUpdateTime are set when first stake occurs\r\n\r\n        metadata = PoolMetadata({\r\n            website: _website,\r\n            telegram: _telegram,\r\n            twitter: _twitter,\r\n            description: _description,\r\n            logoUrl: _logoUrl\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes rewards after factory transfers tokens\r\n     * @dev Only callable by factory. Measures actual token balance to support fee-on-transfer tokens.\r\n     */\r\n    function initializeRewards() external {\r\n        require(msg.sender == factory, \"Only factory can initialize\");\r\n        require(!rewardsDeposited, \"Already initialized\");\r\n\r\n        actualRewardAmount = stakingToken.balanceOf(address(this));\r\n        require(actualRewardAmount > 0, \"No rewards received\");\r\n\r\n        rewardsDeposited = true;\r\n\r\n        emit RewardsDeposited(actualRewardAmount, actualRewardAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Stakes tokens in the pool\r\n     * @dev Supports fee-on-transfer tokens by measuring actual received amount\r\n     * @dev Pool starts on first stake, pauses when empty, resumes on new stake\r\n     * @param _amount Amount of tokens to stake\r\n     */\r\n    function stake(uint256 _amount) external nonReentrant {\r\n        require(rewardsDeposited, \"Rewards not deposited yet\");\r\n        require(_amount > 0, \"Cannot stake 0\");\r\n\r\n        // Handle pool start and pause resumption BEFORE updating rewards\r\n        if (!poolStarted) {\r\n            // First stake ever - start the pool\r\n            poolStarted = true;\r\n            startTime = block.timestamp;\r\n            endTime = block.timestamp + DURATION;\r\n            lastUpdateTime = block.timestamp;\r\n            emit PoolStarted(startTime, endTime);\r\n        } else if (totalStaked == 0 && pauseStartTime > 0) {\r\n            // Resuming from pause - extend endTime by paused duration\r\n            uint256 pausedDuration = block.timestamp - pauseStartTime;\r\n            totalPausedTime += pausedDuration;\r\n            endTime += pausedDuration;\r\n            lastUpdateTime = block.timestamp; // Skip the paused period for rewards\r\n            pauseStartTime = 0;\r\n            emit PoolResumed(pausedDuration, endTime);\r\n        }\r\n\r\n        require(block.timestamp < endTime, \"Pool has ended\");\r\n\r\n        _updateReward(msg.sender);\r\n\r\n        uint256 balanceBefore = stakingToken.balanceOf(address(this));\r\n        stakingToken.transferFrom(msg.sender, address(this), _amount);\r\n        uint256 balanceAfter = stakingToken.balanceOf(address(this));\r\n\r\n        uint256 actualAmount = balanceAfter - balanceBefore;\r\n        require(actualAmount > 0, \"No tokens received\");\r\n\r\n        userInfo[msg.sender].stakedBalance += actualAmount;\r\n        totalStaked += actualAmount;\r\n\r\n        emit Staked(msg.sender, _amount, actualAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstakes tokens and automatically claims rewards\r\n     * @param _amount Amount of tokens to unstake\r\n     */\r\n    function unstake(uint256 _amount) external nonReentrant {\r\n        require(_amount > 0, \"Cannot unstake 0\");\r\n        require(userInfo[msg.sender].stakedBalance >= _amount, \"Insufficient staked balance\");\r\n\r\n        _updateReward(msg.sender);\r\n\r\n        // Claim all pending rewards\r\n        uint256 reward = userInfo[msg.sender].rewards;\r\n        if (reward > 0) {\r\n            userInfo[msg.sender].rewards = 0;\r\n            stakingToken.transfer(msg.sender, reward);\r\n            emit RewardsClaimed(msg.sender, reward);\r\n        }\r\n\r\n        userInfo[msg.sender].stakedBalance -= _amount;\r\n        totalStaked -= _amount;\r\n\r\n        // If pool becomes empty and hasn't ended, start tracking pause time\r\n        if (totalStaked == 0 && poolStarted && block.timestamp < endTime) {\r\n            pauseStartTime = block.timestamp;\r\n            emit PoolPaused(pauseStartTime);\r\n        }\r\n\r\n        stakingToken.transfer(msg.sender, _amount);\r\n\r\n        emit Unstaked(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Claims accumulated rewards\r\n     */\r\n    function claimRewards() external nonReentrant {\r\n        _updateReward(msg.sender);\r\n\r\n        uint256 reward = userInfo[msg.sender].rewards;\r\n        require(reward > 0, \"No rewards to claim\");\r\n\r\n        userInfo[msg.sender].rewards = 0;\r\n        stakingToken.transfer(msg.sender, reward);\r\n\r\n        emit RewardsClaimed(msg.sender, reward);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows creator to withdraw remaining rewards after grace period\r\n     * @dev Can only be called after pool ends + grace period. Does NOT touch staked tokens.\r\n     */\r\n    function withdrawRemainingRewards() external nonReentrant {\r\n        require(msg.sender == creator, \"Only creator\");\r\n        require(!remainingRewardsWithdrawn, \"Already withdrawn\");\r\n\r\n        uint256 withdrawableAfter;\r\n        if (!poolStarted) {\r\n            // Pool never started - creator can withdraw after grace period from creation\r\n            withdrawableAfter = createdAt + gracePeriod;\r\n        } else {\r\n            // Pool started - creator can withdraw after pool ends + grace period\r\n            withdrawableAfter = endTime + gracePeriod;\r\n        }\r\n\r\n        require(block.timestamp > withdrawableAfter, \"Grace period not ended\");\r\n\r\n        // Calculate remaining rewards (total balance minus any staked tokens)\r\n        uint256 totalBalance = stakingToken.balanceOf(address(this));\r\n        uint256 remainingRewards = totalBalance - totalStaked;\r\n        require(remainingRewards > 0, \"No remaining rewards\");\r\n\r\n        remainingRewardsWithdrawn = true;\r\n        stakingToken.transfer(creator, remainingRewards);\r\n\r\n        emit RemainingRewardsWithdrawn(creator, remainingRewards);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates reward per token\r\n     * @return Current reward per token value\r\n     */\r\n    function rewardPerToken() public view returns (uint256) {\r\n        if (!poolStarted || totalStaked == 0) {\r\n            return rewardPerTokenStored;\r\n        }\r\n\r\n        uint256 timeElapsed = _getTimeElapsed();\r\n        uint256 rewardRate = actualRewardAmount / DURATION;\r\n\r\n        return rewardPerTokenStored + (timeElapsed * rewardRate * 1e18 / totalStaked);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates pending rewards for a user\r\n     * @param _user Address of the user\r\n     * @return Amount of pending rewards\r\n     */\r\n    function earned(address _user) public view returns (uint256) {\r\n        UserInfo memory user = userInfo[_user];\r\n        return (user.stakedBalance * (rewardPerToken() - user.rewardPerTokenPaid) / 1e18) + user.rewards;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns pool metadata\r\n     * @return website Project website\r\n     * @return telegram Telegram link\r\n     * @return twitter Twitter handle\r\n     * @return description Project description\r\n     * @return logoUrl Logo URL\r\n     */\r\n    function getMetadata() external view returns (\r\n        string memory website,\r\n        string memory telegram,\r\n        string memory twitter,\r\n        string memory description,\r\n        string memory logoUrl\r\n    ) {\r\n        return (\r\n            metadata.website,\r\n            metadata.telegram,\r\n            metadata.twitter,\r\n            metadata.description,\r\n            metadata.logoUrl\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns user staking information\r\n     * @param _user Address of the user\r\n     * @return stakedBalance Amount of tokens staked\r\n     * @return pendingRewards Amount of pending rewards\r\n     */\r\n    function getUserInfo(address _user) external view returns (\r\n        uint256 stakedBalance,\r\n        uint256 pendingRewards\r\n    ) {\r\n        return (\r\n            userInfo[_user].stakedBalance,\r\n            earned(_user)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns pool statistics\r\n     * @return _totalStaked Total tokens staked in pool\r\n     * @return _totalRewards Total rewards to distribute\r\n     * @return _startTime Pool start timestamp (0 if not started)\r\n     * @return _endTime Pool end timestamp (0 if not started)\r\n     * @return _hasStarted Whether pool has started\r\n     * @return _hasEnded Whether pool has ended\r\n     * @return _isPaused Whether pool is currently paused (no stakers)\r\n     * @return _gracePeriod Grace period in seconds\r\n     */\r\n    function getPoolStats() external view returns (\r\n        uint256 _totalStaked,\r\n        uint256 _totalRewards,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        bool _hasStarted,\r\n        bool _hasEnded,\r\n        bool _isPaused,\r\n        uint256 _gracePeriod\r\n    ) {\r\n        return (\r\n            totalStaked,\r\n            actualRewardAmount,\r\n            startTime,\r\n            endTime,\r\n            poolStarted,\r\n            poolStarted && block.timestamp >= endTime,\r\n            poolStarted && totalStaked == 0 && block.timestamp < endTime,\r\n            gracePeriod\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Updates reward calculations for a user\r\n     * @param _user Address of the user\r\n     */\r\n    function _updateReward(address _user) private {\r\n        rewardPerTokenStored = rewardPerToken();\r\n        lastUpdateTime = block.timestamp > endTime ? endTime : block.timestamp;\r\n\r\n        if (_user != address(0)) {\r\n            userInfo[_user].rewards = earned(_user);\r\n            userInfo[_user].rewardPerTokenPaid = rewardPerTokenStored;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates time elapsed for reward distribution\r\n     * @return Time in seconds\r\n     */\r\n    function _getTimeElapsed() private view returns (uint256) {\r\n        if (!poolStarted) {\r\n            return 0;\r\n        }\r\n        uint256 currentTime = block.timestamp > endTime ? endTime : block.timestamp;\r\n        return currentTime - lastUpdateTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates total rewards distributed so far\r\n     * @return Amount of rewards distributed\r\n     */\r\n    function _distributedRewards() private view returns (uint256) {\r\n        if (!rewardsDeposited || !poolStarted || totalStaked == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 elapsed = (block.timestamp > endTime ? endTime : block.timestamp) - startTime;\r\n        return (actualRewardAmount * elapsed) / DURATION;\r\n    }\r\n}\r\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"@openzeppelin/contracts/utils/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"},"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[],"evmVersion":"paris"}}